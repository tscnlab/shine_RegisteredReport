---
title: "bfda_simulations"
author: "Carolina Guidolin"
date: "2025-06-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Running BFDA with final linear mixed model 
The final linear mixed model formulation is:
melatonin suppression = E2 levels + P4 levels + (1|ID). 
This means that we are accounting for random intercepts but not random slopes. The rational for choosing this model has been discussed in the script bfda_model_selection.Rmd. And explanation of the R notation for linear mixed models in mathematical terms is available [here -- see Table 1](https://doi.org/10.1016/j.jml.2012.11.001).  

## Importing the informed parameters
These have been calculated in the previous script (informed_data_simulation.Rmd)
```{r}
set.seed(20250602)

library(tidyverse)
library(lmerTest)
library(BayesFactor)
library(furrr)

informed_parameters <- read.csv("informed_parameters.csv")

# Keep only cols of interest
informed_parameters <- informed_parameters %>%
  select(intercept_mean, e2_slope_mean, p4_slope_mean) 
```

## Defining model parameters for bfda simulations
```{r}
# Fixed participant number, dictated by resource limitations
n_ids <- 12 

# Select possible values for intercept mean, based on what we know worked from informed_data_simulation
intercept_mean_list <- list(informed_parameters$intercept_mean)

# Select possible values for the slopes (i.e. the betas of the predictors), based on what we know worked from informed_data_simulation
e2_slope_mean_list <- list(informed_parameters$e2_slope_mean)
p4_slope_mean_list <- list(informed_parameters$p4_slope_mean)

# Fix the standard deviations for the intercept and slopes, based on what we know worked
intercept_sd <- 0.2
e2_slope_sd <- 0.2
p4_slope_sd <- 0.2

# Specify values of E2 and P4 (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1

# Define number of simulations to run
num_simulations <- 100 # should ideally be 1000, but simulation crashed when trying values >10 

# Define threshold for Bayes Factor 
bf_threshold <- 3
```

### Running the simulations and generating BFs
```{r}
set.seed(20250602)

# Create empty data frame to store simulated data 
bfda_simulated_data <- data.frame(intercept_mean = numeric(),
                                  e2_slope_mean = numeric(),
                                  p4_slope_mean = numeric(),
                                  TPR = numeric()
                                  )

# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)

for (row in 1:nrow(informed_parameters)) { # looping through each row of the informed_parameter dataframe
  print(paste0("Row:", row))
    
  # Store BFs for simulations
    bf_list <- numeric(num_simulations)  
    
    # Run simulations: for each combination, repeat the simulation n times 
    for (simulation in seq_len(num_simulations)) {
      
      # print(paste0("Simulation:", simulation))
      
      # Sample intercept and slopes from normal distribution of defined parameters
      intercept <- rnorm(n_ids, mean = informed_parameters$intercept_mean[row], sd = intercept_sd)
      e2_slope <- rnorm(n_ids, mean = informed_parameters$e2_slope_mean[row], sd = e2_slope_sd)
      p4_slope <- rnorm(n_ids, mean = informed_parameters$p4_slope_mean[row], sd = p4_slope_sd)
      
      # Simulate data for n_ids individuals
      # We are making the assumption that E2 and P4 are independent (for simplicity)
      sim_data <- data.frame(
        id = factor(rep(1:n_ids, each = 4)),
        e2_value = runif((4*n_ids), e2_min_value, e2_max_value),
        p4_value = runif((4*n_ids), p4_min_value, p4_max_value)
        )
      
      # Create values for y by solving the equation and add noise
      sim_data$y <- intercept[sim_data$id] +
        e2_slope[sim_data$id]*sim_data$e2_value + # e2 slope * e2 value for given id
        p4_slope[sim_data$id]*sim_data$p4_value + # p4 slope * p4 value for given id
        rnorm(n_ids*4,mean = 0, sd = 0.3) # noise ~ N(0, sd=0.3), for each experiment 
      
      sim_data$id0 <- sim_data$id # Keep a copy of id for later use
      
      # Check for absence of NAs in the dataset
      if (anyNA(sim_data)) {
        print(sim_data[!complete.cases(sim_data), ])
        stop(sprintf("NA found in sim_data at row %d, simulation %d", row, simulation))
        }
      
      # print(paste0("Sim data row: ",nrow(sim_data))) # print number of rows for sim_data
      # print(head(sim_data)) # print first few rows of sim_data
      

      # Compute Bayes Factor for full model, with predictors being e2 and p4 levels
      bf_full <- BayesFactor::lmBF(
                                  y ~ e2_value + p4_value + id + id0:p4_value + id0:e2_value,
                                  data = sim_data,
                                  whichRandom = "id",
                                  progress = FALSE) # fitting individual intercept for each id 
      # This function already calculates the ratio between the full model and a model where the intercept is the grand mean
      
    
      # Compute the Bayes Factor for the null model, with predictor being the id variation
      bf_only_intercept <- BayesFactor::lmBF(y ~ id ,
                                   data = sim_data,
                                   whichRandom = "id",
                                   progress = FALSE) # fitting a different intercept for each id
      # This function calculates the ratio between a model where the intercept is different for each id compared to a model where the intercept in the grand mean 
      
      # Take ratio of these two models, meaning the models where intercept is the grand mean cancel each other out
      # So we are effectively taking a ratio between the full model and a model where the intercept is different for id
      bf_ratio <- bf_full/bf_only_intercept
      
      # print(bf_full)
      # print(bf_only_intercept)
      # print(bf_ratio)
      
      # Extract BF value from bf_ratio
      bf_numeric <- as.numeric(BayesFactor::extractBF(bf_ratio)$bf) 
      bf_list[simulation] <- bf_numeric
      
  }
    
  # Compute True Positive Rate (TPR)
  TPR <- sum(bf_list > bf_threshold) / num_simulations
  
  # Store in results
  bfda_simulated_data <- rbind(bfda_simulated_data,
                               data.frame(
                               intercept_mean = informed_parameters$intercept_mean[row],
                               e2_slope_mean = informed_parameters$e2_slope_mean[row],
                               p4_slope_mean = informed_parameters$p4_slope_mean[row],
                               TPR = TPR)
                              )
}


```

## Checking TPR as a function of parameters
```{r}
# Plot heatmap
library(scales)

ggplot(bfda_simulated_data, aes(x = e2_slope_mean, y = p4_slope_mean)) +
  geom_tile(aes(fill = TPR), colour = "black") +
  scale_fill_gradient(low = "white", high = "darkgreen", name = "TPR") +
  labs(
    title = "True positive rate (TPR) for E2 and P4 slope means combinations",
    x = "E2 slope mean",
    y = "P4 slope mean"
  ) +
   scale_x_continuous(
    breaks = seq(-0.5, 0.5, by = 0.1),
    limits = c(-0.5, 0.5)
  ) +
  scale_y_continuous(
    breaks = seq(-0.5, 0.5, by = 0.1),
    limits = c(-0.5, 0.5)
  ) +
  coord_fixed(ratio = 1) +
  theme_bw() +
  theme(
    aspect.ratio = 1,
    panel.grid = element_blank(),  # clean up grid lines inside tiles
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)
  )

```


```{r}
bfda_simulated_data <- read.csv("bfda_simulated_data.csv")

library(dplyr)
all.equal(bfda_simulated_data_parallel, bfda_simulated_data)

```

```{r}
# Run parallel simulations
new_bfda_simulated_data_parallel_100 <- future_map_dfr(1:nrow(informed_parameters), function(row) {
  
  bf_list <- numeric(num_simulations)
  
  for (simulation in seq_len(num_simulations)) {
    
    intercept <- rnorm(n_ids, mean = informed_parameters$intercept_mean[row], sd = intercept_sd)
    e2_slope  <- rnorm(n_ids, mean = informed_parameters$e2_slope_mean[row], sd = e2_slope_sd)
    p4_slope  <- rnorm(n_ids, mean = informed_parameters$p4_slope_mean[row], sd = p4_slope_sd)
    
    sim_data <- data.frame(
      id = factor(rep(1:n_ids, each = 4)),
      e2_value = runif(4 * n_ids, e2_min_value, e2_max_value),
      p4_value = runif(4 * n_ids, p4_min_value, p4_max_value)
    )
    
    sim_data$y <- intercept[sim_data$id] +
      e2_slope[sim_data$id] * sim_data$e2_value +
      p4_slope[sim_data$id] * sim_data$p4_value +
      rnorm(n_ids * 4, mean = 0, sd = 0.3)
    
    sim_data$id0 <- sim_data$id
    
    if (anyNA(sim_data)) stop(sprintf("NA found in sim_data at row %d, simulation %d", row, simulation))
    
    bf_full <- BayesFactor::lmBF(
      y ~ e2_value + p4_value + id + id0:p4_value + id0:e2_value,
      data = sim_data,
      whichRandom = "id",
      progress = FALSE
    )
    
    bf_only_intercept <- BayesFactor::lmBF(
      y ~ id,
      data = sim_data,
      whichRandom = "id",
      progress = FALSE
    )
    
    bf_ratio <- bf_full / bf_only_intercept
    bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf_ratio)$bf)
  }
  
  TPR <- sum(bf_list > bf_threshold) / num_simulations
  
  # Return one row per `row`
  tibble::tibble(
    intercept_mean = informed_parameters$intercept_mean[row],
    e2_slope_mean  = informed_parameters$e2_slope_mean[row],
    p4_slope_mean  = informed_parameters$p4_slope_mean[row],
    TPR = TPR
  )
},
.options = furrr_options(seed = 20250602) # setting seed so we always get the same thing 
)

write.csv(new_bfda_simulated_data_parallel_100, "new_bfda_simulated_data_100_parallelised.csv", row.names = FALSE)


```

```{r}
write.csv(bfda_simulated_data_parallel1, "bfa_simulated_data_100_parallelised1.csv", row.names = FALSE)
write.csv(bfda_simulated_data_parallel, "bfa_simulated_data_100_parallelised.csv", row.names = FALSE)

```

