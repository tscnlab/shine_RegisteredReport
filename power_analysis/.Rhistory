bfda_all_bfs,
data.frame(
row = row,
simulation = simulation,
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
BF = bf_numeric
)
)
}
# Compute True Positive Rate (TPR)
TPR <- sum(bf_list > bf_threshold) / num_simulations
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
TPR = TPR)
)
}
set.seed(20250602)
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create an empty dataframe to store all BFs
bfda_all_bfs <- data.frame(
row = numeric(),
simulation = numeric(),
intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
BF = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (row in 1:nrow(informed_parameters)) { # looping through each row of the informed_parameter dataframe
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
print(paste0("Row:", row))
print(paste0("Simulation:", simulation))
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(n_ids, mean = informed_parameters$intercept_mean[row], sd = intercept_sd)
e2_slope <- rnorm(n_ids, mean = informed_parameters$e2_slope_mean[row], sd = e2_slope_sd)
p4_slope <- rnorm(n_ids, mean = informed_parameters$p4_slope_mean[row], sd = p4_slope_sd)
# Simulate data for n_ids individuals
# We are making the assumption that E2 and P4 are independent (for simplicity)
sim_data <- data.frame(
id = factor(rep(1:n_ids, each = 10)),
e2_value = runif((10*n_ids), e2_min_value, e2_max_value),
p4_value = runif((10*n_ids), p4_min_value, p4_max_value)
)
# Create values for y by solving the equation and add noise
sim_data$y <- intercept[sim_data$id] +
e2_slope[sim_data$id]*sim_data$e2_value + # e2 slope * e2 value for given id
p4_slope[sim_data$id]*sim_data$p4_value + # p4 slope * p4 value for given id
rnorm(n_ids*10, mean = 0, sd = 0.3) # noise ~ N(0, sd=0.3), for each experiment
# Check for absence of NAs
if (anyNA(sim_data)) {
print(sim_data[!complete.cases(sim_data), ])
stop(sprintf("NA found in sim_data at row %d, simulation %d", row, simulation))
}
print(paste0("Sim data row",nrow(sim_data))) # print number of rows for sim_data
# Compute Bayes Factor for full model, with predictors being e2 and p4 levels
bf_full <- BayesFactor::lmBF(y ~ e2_value + p4_value + id + id:e2_value + id:p4_value,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting individual slope and intercept for each id
# This function already calculates the ratio between the full model and a model where the intercept is the grand mean
# Compute the Bayes Factor for the null model, with predictor being the id variation
bf_only_intercept <- BayesFactor::lmBF(y ~ id,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting a different intercept for each id
# This function calculates the ratio between a model where the intercept is different for each id compared to a model where the intercept in the grand mean
# Take ratio of these two models, meaning the models where intercept is the grand mean cancel each other out
# So we are effectively taking a ratio between the full model and a model where the intercept is different for id
bf_ratio <- bf_full/bf_only_intercept
print(bf_full)
print(bf_only_intercept)
print(bf_ratio)
# Extract BF value from bf_ratio
bf_numeric <- as.numeric(BayesFactor::extractBF(bf_ratio)$bf)
bf_list[simulation] <- bf_numeric
# Store each BF with its parameters
bfda_all_bfs <- rbind(
bfda_all_bfs,
data.frame(
row = row,
simulation = simulation,
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
BF = bf_numeric
)
)
}
# Compute True Positive Rate (TPR)
TPR <- sum(bf_list > bf_threshold) / num_simulations
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
TPR = TPR)
)
}
set.seed(20250602)
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create an empty dataframe to store all BFs
bfda_all_bfs <- data.frame(
row = numeric(),
simulation = numeric(),
intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
BF = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (row in 1:nrow(informed_parameters)) { # looping through each row of the informed_parameter dataframe
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
print(paste0("Row:", row))
print(paste0("Simulation:", simulation))
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(n_ids, mean = informed_parameters$intercept_mean[row], sd = intercept_sd)
e2_slope <- rnorm(n_ids, mean = informed_parameters$e2_slope_mean[row], sd = e2_slope_sd)
p4_slope <- rnorm(n_ids, mean = informed_parameters$p4_slope_mean[row], sd = p4_slope_sd)
# Simulate data for n_ids individuals
# We are making the assumption that E2 and P4 are independent (for simplicity)
sim_data <- data.frame(
id = factor(rep(1:n_ids, each = 20)),
e2_value = runif((20*n_ids), e2_min_value, e2_max_value),
p4_value = runif((20*n_ids), p4_min_value, p4_max_value)
)
# Create values for y by solving the equation and add noise
sim_data$y <- intercept[sim_data$id] +
e2_slope[sim_data$id]*sim_data$e2_value + # e2 slope * e2 value for given id
p4_slope[sim_data$id]*sim_data$p4_value + # p4 slope * p4 value for given id
rnorm(n_ids*20, mean = 0, sd = 0.3) # noise ~ N(0, sd=0.3), for each experiment
# Check for absence of NAs in the dataset
if (anyNA(sim_data)) {
print(sim_data[!complete.cases(sim_data), ])
stop(sprintf("NA found in sim_data at row %d, simulation %d", row, simulation))
}
print(paste0("Sim data row",nrow(sim_data))) # print number of rows for sim_data
# Compute Bayes Factor for full model, with predictors being e2 and p4 levels
bf_full <- BayesFactor::lmBF(y ~ e2_value + p4_value + id + id:e2_value + id:p4_value,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting individual slope and intercept for each id
# This function already calculates the ratio between the full model and a model where the intercept is the grand mean
# Compute the Bayes Factor for the null model, with predictor being the id variation
bf_only_intercept <- BayesFactor::lmBF(y ~ id,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting a different intercept for each id
# This function calculates the ratio between a model where the intercept is different for each id compared to a model where the intercept in the grand mean
# Take ratio of these two models, meaning the models where intercept is the grand mean cancel each other out
# So we are effectively taking a ratio between the full model and a model where the intercept is different for id
bf_ratio <- bf_full/bf_only_intercept
print(bf_full)
print(bf_only_intercept)
print(bf_ratio)
# Extract BF value from bf_ratio
bf_numeric <- as.numeric(BayesFactor::extractBF(bf_ratio)$bf)
bf_list[simulation] <- bf_numeric
# Store each BF with its parameters
bfda_all_bfs <- rbind(
bfda_all_bfs,
data.frame(
row = row,
simulation = simulation,
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
BF = bf_numeric
)
)
}
# Compute True Positive Rate (TPR)
TPR <- sum(bf_list > bf_threshold) / num_simulations
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
TPR = TPR)
)
}
View(bfda_simulated_data)
library(tidyverse)
# Importing data
mlt_data <- read.csv("VR_paper_melatonin_results.csv")
# Calculating summary statistics on raw data
mlt_raw_data_summary <- mlt_data %>%
summarise(mean = mean(mel_supp),
sd = sd(mel_supp),
median = median(mel_supp),
iqr = IQR(mel_supp),
q1 = quantile(mel_supp, 0.25),
q3 = quantile(mel_supp, 0.75))
# Standardise raw data so that it falls between -1 and 1
mlt_data_standardised <- mlt_data %>%
mutate(mel_supp_standardised = (mel_supp - mean(mel_supp))/sd(mel_supp)
)
# Calculating summary statistics on standardised data
mlt_data_standardised_summary <- mlt_data_standardised %>%
summarise(mean = mean(mel_supp_standardised),
sd = sd(mel_supp_standardised),
median = median(mel_supp_standardised),
q1 = quantile(mel_supp_standardised, 0.25),
q3 = quantile(mel_supp_standardised, 0.75)
)
View(mlt_data_standardised_summary)
library(tidyverse)
# Importing data
mlt_data <- read.csv("VR_paper_melatonin_results.csv")
# Calculating summary statistics on raw data
mlt_raw_data_summary <- mlt_data %>%
summarise(mean = mean(mel_supp),
sd = sd(mel_supp),
median = median(mel_supp),
iqr = IQR(mel_supp),
q1 = quantile(mel_supp, 0.25),
q3 = quantile(mel_supp, 0.75))
# Standardise raw data so that it falls between -1 and 1
mlt_data_standardised <- mlt_data %>%
mutate(mel_supp_standardised = (mel_supp - mean(mel_supp))/sd(mel_supp)
)
# Calculating summary statistics on standardised data
mlt_data_standardised_summary <- mlt_data_standardised %>%
summarise(mean = mean(mel_supp_standardised),
sd = sd(mel_supp_standardised),
median = median(mel_supp_standardised),
q1 = quantile(mel_supp_standardised, 0.25),
q3 = quantile(mel_supp_standardised, 0.75)
)
View(mlt_data_standardised)
View(mlt_data_standardised_summary)
View(mlt_data_standardised)
mean(mlt_data_standardised$mel_supp_standardised)
scipen(999)
options(scipen=999)
mean(mlt_data_standardised$mel_supp_standardised)
View(mlt_data_standardised)
knitr::opts_chunk$set(echo = TRUE)
# Load required package
library(BayesFactor)
library(tidyverse)
# Set seed for reproducibility
set.seed(20250602)
# Define simulation parameters
n_ids <- 12 # Number of subjects in BFDA
obs_per_id <- 4 # Observations per subject
total_obs <- n_ids * obs_per_id
# Simulate subject-specific intercepts and slopes
intercept_mean <- 0.0
e2_slope_mean <- 0.5
p4_slope_mean <- -0.5
intercept_sd <- 0.2
e2_slope_sd <- 0.1
p4_slope_sd <- 0.1
intercepts <- rnorm(n_ids, mean = intercept_mean, sd = intercept_sd)
e2_slopes <- rnorm(n_ids, mean = e2_slope_mean, sd = e2_slope_sd)
p4_slopes <- rnorm(n_ids, mean = p4_slope_mean, sd = p4_slope_sd)
# Simulate predictors
sim_data <- data.frame(
id = factor(rep(1:n_ids, each = obs_per_id)),
e2_value = runif(total_obs, min = 0, max = 1),
p4_value = runif(total_obs, min = 0, max = 1)
)
# Generate response variable with noise
sim_data$y <- intercepts[sim_data$id] +
e2_slopes[sim_data$id] * sim_data$e2_value +
p4_slopes[sim_data$id] * sim_data$p4_value +
rnorm(total_obs, mean = 0, sd = 0.3)
# Check for NAs
stopifnot(!anyNA(sim_data))
# Fit full and null Bayes factor models
bf_full <- BayesFactor::lmBF(
y ~ e2_value + p4_value + id + id:e2_value + id:p4_value,
data = sim_data,
whichRandom = "id",
progress = FALSE
)
bf_null <- BayesFactor::lmBF(
y ~ id,
data = sim_data,
whichRandom = "id",
progress = FALSE
)
# Compute ratio
bf_ratio <- bf_full / bf_null
# Print results
print(bf_full)
print(bf_null)
print(bf_ratio)
# Extract numeric BF value
bf_val <- as.numeric(extractBF(bf_ratio)$bf)
print(bf_val)
View(sim_data)
# Check for NAs
stopifnot(!anyNA(sim_data))
library(tidyverse)
library(BayesFactor)
informed_parameters <- read.csv("informed_parameters.csv")
# Keep only cols of interest
informed_parameters <- informed_parameters %>%
select(intercept_mean, e2_slope_mean, p4_slope_mean) %>%
slice(1:100)
# Fixed participant number, dictated by resource limitations
n_ids <- 12
# Select possible values for intercept mean, based on what we know worked
intercept_mean_list <- list(informed_parameters$intercept_mean)
# Select possible values for the slopes (i.e. the betas of the predictors), based on what we know worked
e2_slope_mean_list <- list(informed_parameters$e2_slope_mean)
p4_slope_mean_list <- list(informed_parameters$p4_slope_mean)
# Fix the standard deviations for the intercept and slopes, based on what we know worked
intercept_sd <- 0.2
e2_slope_sd <- 0.2
p4_slope_sd <- 0.2
# Specify values of E2 and P4 (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Define number of simulations to run
num_simulations <- 3
# Define threshold for Bayes Factor
bf_threshold <- 3
# Fixed participant number, dictated by resource limitations
n_ids <- 12
# Select possible values for intercept mean, based on what we know worked
intercept_mean_list <- list(informed_parameters$intercept_mean)
# Select possible values for the slopes (i.e. the betas of the predictors), based on what we know worked
e2_slope_mean_list <- list(informed_parameters$e2_slope_mean)
p4_slope_mean_list <- list(informed_parameters$p4_slope_mean)
# Fix the standard deviations for the intercept and slopes, based on what we know worked
intercept_sd <- 0.2
e2_slope_sd <- 0.2
p4_slope_sd <- 0.2
# Specify values of E2 and P4 (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Define number of simulations to run
num_simulations <- 1
# Define threshold for Bayes Factor
bf_threshold <- 3
set.seed(20250602)
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create an empty dataframe to store all BFs
bfda_all_bfs <- data.frame(
row = numeric(),
simulation = numeric(),
intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
BF = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (row in 1:nrow(informed_parameters)) { # looping through each row of the informed_parameter dataframe
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
print(paste0("Row:", row))
print(paste0("Simulation:", simulation))
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(n_ids, mean = informed_parameters$intercept_mean[row], sd = intercept_sd)
e2_slope <- rnorm(n_ids, mean = informed_parameters$e2_slope_mean[row], sd = e2_slope_sd)
p4_slope <- rnorm(n_ids, mean = informed_parameters$p4_slope_mean[row], sd = p4_slope_sd)
# Simulate data for n_ids individuals
# We are making the assumption that E2 and P4 are independent (for simplicity)
sim_data <- data.frame(
id = factor(rep(1:n_ids, each = 20)),
e2_value = runif((20*n_ids), e2_min_value, e2_max_value),
p4_value = runif((20*n_ids), p4_min_value, p4_max_value)
)
# Create values for y by solving the equation and add noise
sim_data$y <- intercept[sim_data$id] +
e2_slope[sim_data$id]*sim_data$e2_value + # e2 slope * e2 value for given id
p4_slope[sim_data$id]*sim_data$p4_value + # p4 slope * p4 value for given id
rnorm(n_ids*20, mean = 0, sd = 0.3) # noise ~ N(0, sd=0.3), for each experiment
# Check for absence of NAs in the dataset
if (anyNA(sim_data)) {
print(sim_data[!complete.cases(sim_data), ])
stop(sprintf("NA found in sim_data at row %d, simulation %d", row, simulation))
}
print(paste0("Sim data row",nrow(sim_data))) # print number of rows for sim_data
# Compute Bayes Factor for full model, with predictors being e2 and p4 levels
bf_full <- BayesFactor::lmBF(y ~ e2_value + p4_value + id + id:e2_value + id:p4_value,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting individual slope and intercept for each id
# This function already calculates the ratio between the full model and a model where the intercept is the grand mean
# Compute the Bayes Factor for the null model, with predictor being the id variation
bf_only_intercept <- BayesFactor::lmBF(y ~ id + id:e2_value + id:p4_value,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting a different intercept for each id
# This function calculates the ratio between a model where the intercept is different for each id compared to a model where the intercept in the grand mean
# Take ratio of these two models, meaning the models where intercept is the grand mean cancel each other out
# So we are effectively taking a ratio between the full model and a model where the intercept is different for id
bf_ratio <- bf_full/bf_only_intercept
print(bf_full)
print(bf_only_intercept)
print(bf_ratio)
# Extract BF value from bf_ratio
bf_numeric <- as.numeric(BayesFactor::extractBF(bf_ratio)$bf)
bf_list[simulation] <- bf_numeric
# Store each BF with its parameters
bfda_all_bfs <- rbind(
bfda_all_bfs,
data.frame(
row = row,
simulation = simulation,
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
BF = bf_numeric
)
)
}
# Compute True Positive Rate (TPR)
TPR <- sum(bf_list > bf_threshold) / num_simulations
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
TPR = TPR)
)
}
# Load required package
library(BayesFactor)
library(tidyverse)
# Set seed for reproducibility
set.seed(20250602)
# Define simulation parameters
n_ids <- 12 # Number of subjects in BFDA
obs_per_id <- 4 # Observations per subject
total_obs <- n_ids * obs_per_id
# Simulate subject-specific intercepts and slopes
intercept_mean <- 0.0
e2_slope_mean <- 0.5
p4_slope_mean <- -0.5
intercept_sd <- 0.2
e2_slope_sd <- 0.1
p4_slope_sd <- 0.1
intercepts <- rnorm(n_ids, mean = intercept_mean, sd = intercept_sd)
e2_slopes <- rnorm(n_ids, mean = e2_slope_mean, sd = e2_slope_sd)
p4_slopes <- rnorm(n_ids, mean = p4_slope_mean, sd = p4_slope_sd)
# Simulate predictors
sim_data <- data.frame(
id = factor(rep(1:n_ids, each = obs_per_id)),
e2_value = runif(total_obs, min = 0, max = 1),
p4_value = runif(total_obs, min = 0, max = 1)
)
# Generate response variable with noise
sim_data$y <- intercepts[sim_data$id] +
e2_slopes[sim_data$id] * sim_data$e2_value +
p4_slopes[sim_data$id] * sim_data$p4_value +
rnorm(total_obs, mean = 0, sd = 0.3)
# Check for NAs
stopifnot(!anyNA(sim_data))
# Fit full and null Bayes factor models
# Full models against model with grand intercept only
bf_full <- BayesFactor::lmBF(
y ~ e2_value + p4_value + id + id:e2_value + id:p4_value,
data = sim_data,
whichRandom = "id",
progress = FALSE
)
#
bf_null <- BayesFactor::lmBF(
y ~ id,
data = sim_data,
whichRandom = "id",
progress = FALSE
)
# Compute ratio
bf_ratio <- bf_full / bf_null
# Print results
print(bf_full)
print(bf_null)
print(bf_ratio)
# Extract numeric BF value
bf_val <- as.numeric(extractBF(bf_ratio)$bf)
print(bf_val)
