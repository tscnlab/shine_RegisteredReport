row = numeric(),
simulation = numeric(),
intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
BF = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (row in 1:nrow(informed_parameters)) { # looping through each row of the informed_parameter dataframe
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
print(paste0("Row:", row))
print(paste0("Simulation:", simulation))
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(n_ids, mean = informed_parameters$intercept_mean[row], sd = intercept_sd)
e2_slope <- rnorm(n_ids, mean = informed_parameters$e2_slope_mean[row], sd = e2_slope_sd)
p4_slope <- rnorm(n_ids, mean = informed_parameters$p4_slope_mean[row], sd = p4_slope_sd)
# Simulate data for n_ids individuals
# We are making the assumption that E2 and P4 are independent (for simplicity)
sim_data <- data.frame(
id = factor(rep(1:n_ids, each = 20)),
e2_value = runif((20*n_ids), e2_min_value, e2_max_value),
p4_value = runif((20*n_ids), p4_min_value, p4_max_value)
)
# Create values for y by solving the equation and add noise
sim_data$y <- intercept[sim_data$id] +
e2_slope[sim_data$id]*sim_data$e2_value + # e2 slope * e2 value for given id
p4_slope[sim_data$id]*sim_data$p4_value + # p4 slope * p4 value for given id
rnorm(n_ids*20, mean = 0, sd = 0.3) # noise ~ N(0, sd=0.3), for each experiment
# Check for absence of NAs in the dataset
if (anyNA(sim_data)) {
print(sim_data[!complete.cases(sim_data), ])
stop(sprintf("NA found in sim_data at row %d, simulation %d", row, simulation))
}
print(paste0("Sim data row",nrow(sim_data))) # print number of rows for sim_data
# Compute Bayes Factor for full model, with predictors being e2 and p4 levels
bf_full <- BayesFactor::lmBF(y ~ e2_value + p4_value + id + id:e2_value + id:p4_value,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting individual slope and intercept for each id
# This function already calculates the ratio between the full model and a model where the intercept is the grand mean
# Compute the Bayes Factor for the null model, with predictor being the id variation
bf_only_intercept <- BayesFactor::lmBF(y ~ id + id:e2_value + id:p4_value,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting a different intercept for each id
# This function calculates the ratio between a model where the intercept is different for each id compared to a model where the intercept in the grand mean
# Take ratio of these two models, meaning the models where intercept is the grand mean cancel each other out
# So we are effectively taking a ratio between the full model and a model where the intercept is different for id
bf_ratio <- bf_full/bf_only_intercept
print(bf_full)
print(bf_only_intercept)
print(bf_ratio)
# Extract BF value from bf_ratio
bf_numeric <- as.numeric(BayesFactor::extractBF(bf_ratio)$bf)
bf_list[simulation] <- bf_numeric
# Store each BF with its parameters
bfda_all_bfs <- rbind(
bfda_all_bfs,
data.frame(
row = row,
simulation = simulation,
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
BF = bf_numeric
)
)
}
# Compute True Positive Rate (TPR)
TPR <- sum(bf_list > bf_threshold) / num_simulations
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
TPR = TPR)
)
}
# Load required package
library(BayesFactor)
library(tidyverse)
# Set seed for reproducibility
set.seed(20250602)
# Define simulation parameters
n_ids <- 12 # Number of subjects in BFDA
obs_per_id <- 4 # Observations per subject
total_obs <- n_ids * obs_per_id
# Simulate subject-specific intercepts and slopes
intercept_mean <- 0.0
e2_slope_mean <- 0.5
p4_slope_mean <- -0.5
intercept_sd <- 0.2
e2_slope_sd <- 0.1
p4_slope_sd <- 0.1
intercepts <- rnorm(n_ids, mean = intercept_mean, sd = intercept_sd)
e2_slopes <- rnorm(n_ids, mean = e2_slope_mean, sd = e2_slope_sd)
p4_slopes <- rnorm(n_ids, mean = p4_slope_mean, sd = p4_slope_sd)
# Simulate predictors
sim_data <- data.frame(
id = factor(rep(1:n_ids, each = obs_per_id)),
e2_value = runif(total_obs, min = 0, max = 1),
p4_value = runif(total_obs, min = 0, max = 1)
)
# Generate response variable with noise
sim_data$y <- intercepts[sim_data$id] +
e2_slopes[sim_data$id] * sim_data$e2_value +
p4_slopes[sim_data$id] * sim_data$p4_value +
rnorm(total_obs, mean = 0, sd = 0.3)
# Check for NAs
stopifnot(!anyNA(sim_data))
# Fit full and null Bayes factor models
# Full models against model with grand intercept only
bf_full <- BayesFactor::lmBF(
y ~ e2_value + p4_value + id + id:e2_value + id:p4_value,
data = sim_data,
whichRandom = "id",
progress = FALSE
)
#
bf_null <- BayesFactor::lmBF(
y ~ id,
data = sim_data,
whichRandom = "id",
progress = FALSE
)
# Compute ratio
bf_ratio <- bf_full / bf_null
# Print results
print(bf_full)
print(bf_null)
print(bf_ratio)
# Extract numeric BF value
bf_val <- as.numeric(extractBF(bf_ratio)$bf)
print(bf_val)
library(lmerTest)
library(lme4)
# Run diagnostics on all simulated datasets
model_diagnostics <- lapply(names(all_sim_data), function(name) {
dat <- all_sim_data[[name]]
fit <- tryCatch(
lmer(y ~ e2_value + p4_value + (1 + e2_value + p4_value | id), data = dat),
error = function(e) return(list(error = e$message, name = name))
)
if (inherits(fit, "list")) {
return(fit)  # return error list with name
}
# Extract summary and diagnostics
list(
name = name,
is_singular = isSingular(fit),
convergence_warnings = fit@optinfo$conv$lme4$messages,
summary = summary(fit)
)
})
# Optional: convert to data.frame for viewing
diagnostic_overview <- do.call(rbind, lapply(model_diagnostics, function(x) {
if (!is.list(x) || !"name" %in% names(x)) return(NULL)
data.frame(
sim_name = x$name,
is_singular = ifelse("is_singular" %in% names(x), x$is_singular, NA),
has_convergence_warning = ifelse("convergence_warnings" %in% names(x) && !is.null(x$convergence_warnings), TRUE, FALSE),
error = ifelse("error" %in% names(x), x$error, NA),
stringsAsFactors = FALSE
)
}))
library(lmerTest)
library(lme4)
# Run diagnostics on all simulated datasets
model_diagnostics <- lapply(names(all_sim_data), function(name) {
dat <- all_sim_data[[name]]
fit <- tryCatch(
lmer(y ~ e2_value + p4_value + (1 + e2_value + p4_value | id), data = dat),
error = function(e) return(list(error = e$message, name = name))
)
if (inherits(fit, "list")) {
return(fit)  # return error list with name
}
# Extract summary and diagnostics
list(
name = name,
is_singular = isSingular(fit),
convergence_warnings = fit@optinfo$conv$lme4$messages,
summary = summary(fit)
)
})
# Optional: convert to data.frame for viewing
diagnostic_overview <- do.call(rbind, lapply(model_diagnostics, function(x) {
if (!is.list(x) || !"name" %in% names(x)) return(NULL)
data.frame(
sim_name = x$name,
is_singular = ifelse("is_singular" %in% names(x), x$is_singular, NA),
has_convergence_warning = ifelse("convergence_warnings" %in% names(x) && !is.null(x$convergence_warnings), TRUE, FALSE),
error = ifelse("error" %in% names(x), x$error, NA),
stringsAsFactors = FALSE
)
}))
# Run diagnostics on all simulated datasets
model_diagnostics <- lapply(names(all_sim_data), function(name) {
dat <- all_sim_data[[name]]
fit <- tryCatch(
lmer(y ~ e2_value + p4_value + (1 + e2_value + p4_value | id), data = dat),
error = function(e) return(list(error = e$message, name = name))
)
if (inherits(fit, "list")) {
return(fit)  # return error list with name
}
# Extract summary and diagnostics
list(
name = name,
is_singular = isSingular(fit),
convergence_warnings = fit@optinfo$conv$lme4$messages,
summary = summary(fit)
)
})
# Optional: convert to data.frame for viewing
diagnostic_overview <- do.call(rbind, lapply(model_diagnostics, function(x) {
if (!is.list(x) || !"name" %in% names(x)) return(NULL)
data.frame(
sim_name = x$name,
is_singular = ifelse("is_singular" %in% names(x), x$is_singular, NA),
has_convergence_warning = ifelse("convergence_warnings" %in% names(x) && !is.null(x$convergence_warnings), TRUE, FALSE),
error = ifelse("error" %in% names(x), x$error, NA),
stringsAsFactors = FALSE
)
}))
str(all_sim_data, max.level = 1)
# Fixed participant number, dictated by resource limitations
n_ids <- 12
# Select possible values for intercept mean, based on what we know worked
intercept_mean_list <- list(informed_parameters$intercept_mean)
# Select possible values for the slopes (i.e. the betas of the predictors), based on what we know worked
e2_slope_mean_list <- list(informed_parameters$e2_slope_mean)
p4_slope_mean_list <- list(informed_parameters$p4_slope_mean)
# Fix the standard deviations for the intercept and slopes, based on what we know worked
intercept_sd <- 0.2
e2_slope_sd <- 0.2
p4_slope_sd <- 0.2
# Specify values of E2 and P4 (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Define number of simulations to run
num_simulations <- 1
# Define threshold for Bayes Factor
bf_threshold <- 3
set.seed(20250602)
# Store all simulated datasets for later diagnostics or modeling
all_sim_data <- list()
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create an empty dataframe to store all BFs
bfda_all_bfs <- data.frame(
row = numeric(),
simulation = numeric(),
intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
BF = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (row in 1:nrow(informed_parameters)) { # looping through each row of the informed_parameter dataframe
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
print(paste0("Row:", row))
print(paste0("Simulation:", simulation))
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(n_ids, mean = informed_parameters$intercept_mean[row], sd = intercept_sd)
e2_slope <- rnorm(n_ids, mean = informed_parameters$e2_slope_mean[row], sd = e2_slope_sd)
p4_slope <- rnorm(n_ids, mean = informed_parameters$p4_slope_mean[row], sd = p4_slope_sd)
# Simulate data for n_ids individuals
# We are making the assumption that E2 and P4 are independent (for simplicity)
sim_data <- data.frame(
id = factor(rep(1:n_ids, each = 4)),
e2_value = runif((4*n_ids), e2_min_value, e2_max_value),
p4_value = runif((4*n_ids), p4_min_value, p4_max_value)
)
# Create values for y by solving the equation and add noise
sim_data$y <- intercept[sim_data$id] +
e2_slope[sim_data$id]*sim_data$e2_value + # e2 slope * e2 value for given id
p4_slope[sim_data$id]*sim_data$p4_value + # p4 slope * p4 value for given id
rnorm(n_ids*4,mean = 0, sd = 0.3) # noise ~ N(0, sd=0.3), for each experiment
# Save sim_data for later diagnostics
all_sim_data[[paste0("row", row, "_sim", simulation)]] <- sim_data
# Check for absence of NAs in the dataset
if (anyNA(sim_data)) {
print(sim_data[!complete.cases(sim_data), ])
stop(sprintf("NA found in sim_data at row %d, simulation %d", row, simulation))
}
print(paste0("Sim data row",nrow(sim_data))) # print number of rows for sim_data
# Compute Bayes Factor for full model, with predictors being e2 and p4 levels
bf_full <- BayesFactor::lmBF(y ~ e2_value + p4_value + id,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting individual slope and intercept for each id
# This function already calculates the ratio between the full model and a model where the intercept is the grand mean
# Compute the Bayes Factor for the null model, with predictor being the id variation
bf_only_intercept <- BayesFactor::lmBF(y ~ id ,
data = sim_data,
whichRandom = "id",
progress = FALSE) # fitting a different intercept for each id
# This function calculates the ratio between a model where the intercept is different for each id compared to a model where the intercept in the grand mean
# Take ratio of these two models, meaning the models where intercept is the grand mean cancel each other out
# So we are effectively taking a ratio between the full model and a model where the intercept is different for id
bf_ratio <- bf_full/bf_only_intercept
print(bf_full)
print(bf_only_intercept)
print(bf_ratio)
# Extract BF value from bf_ratio
bf_numeric <- as.numeric(BayesFactor::extractBF(bf_ratio)$bf)
bf_list[simulation] <- bf_numeric
# Store each BF with its parameters
bfda_all_bfs <- rbind(
bfda_all_bfs,
data.frame(
row = row,
simulation = simulation,
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
BF = bf_numeric
)
)
}
# Compute True Positive Rate (TPR)
TPR <- sum(bf_list > bf_threshold) / num_simulations
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
intercept_mean = informed_parameters$intercept_mean[row],
e2_slope_mean = informed_parameters$e2_slope_mean[row],
p4_slope_mean = informed_parameters$p4_slope_mean[row],
TPR = TPR)
)
}
View(bfda_all_bfs)
View(bfda_simulated_data)
library(lmerTest)
library(lme4)
# Run diagnostics on all simulated datasets
model_diagnostics <- lapply(names(all_sim_data), function(name) {
dat <- all_sim_data[[name]]
fit <- tryCatch(
lmer(y ~ e2_value + p4_value + (1 + e2_value + p4_value | id), data = dat),
error = function(e) return(list(error = e$message, name = name))
)
if (inherits(fit, "list")) {
return(fit)  # return error list with name
}
# Extract summary and diagnostics
list(
name = name,
is_singular = isSingular(fit),
convergence_warnings = fit@optinfo$conv$lme4$messages,
summary = summary(fit)
)
})
# Optional: convert to data.frame for viewing
diagnostic_overview <- do.call(rbind, lapply(model_diagnostics, function(x) {
if (!is.list(x) || !"name" %in% names(x)) return(NULL)
data.frame(
sim_name = x$name,
is_singular = ifelse("is_singular" %in% names(x), x$is_singular, NA),
has_convergence_warning = ifelse("convergence_warnings" %in% names(x) && !is.null(x$convergence_warnings), TRUE, FALSE),
error = ifelse("error" %in% names(x), x$error, NA),
stringsAsFactors = FALSE
)
}))
View(diagnostic_overview)
View(model_diagnostics)
summary(
lmerTest::lmer(
y ~ e2_value + p4_value + (1 + e2_value + p4_value | id),
data = all_sim_data[["row1_sim1"]]
)
)
# Checking how many models managed to converge
diagnostic_overview_summary <- diagnostic_overview %>%
summarise(is_singular == TRUE)
library(tidyverse)
# Checking how many models managed to converge
diagnostic_overview_summary <- diagnostic_overview %>%
summarise(is_singular == TRUE)
View(diagnostic_overview_summary)
# Checking how many models managed to converge
diagnostic_overview_summary <- diagnostic_overview %>%
summary(is_singular == TRUE)
View(mlt_raw_data_summary)
View(mlt_data_standardised_summary)
# Checking how many models managed to converge
diagnostic_overview_summary <- diagnostic_overview %>%
summary(is_singular == TRUE)
# Checking how many models managed to converge
diagnostic_overview %>%
summarise(
num_singular = sum(is_singular, na.rm = TRUE),
num_with_convergence_warning = sum(has_convergence_warning, na.rm = TRUE),
num_with_error = sum(!is.na(error))
)
# Checking how many models managed to converge
diagnostic_overview %>%
summarise(
num_singular = sum(!is_singular, na.rm = TRUE),
num_with_convergence_warning = sum(has_convergence_warning, na.rm = TRUE),
num_with_error = sum(!is.na(error))
)
# Checking how many models managed to converge
diagnostic_overview %>%
summarise(
num_singular = sum(is_singular, na.rm = TRUE),
num_with_convergence_warning = sum(has_convergence_warning, na.rm = TRUE),
num_with_error = sum(!is.na(error))
)
model1 <- y ~ e2_value + p4_value + (1 + e2_value + p4_value | id)
diag_model1 <- run_model_diagnostics(model1, all_sim_data)
run_model_diagnostics <- function(model_formula, data_list) {
lapply(names(data_list), function(name) {
dat <- data_list[[name]]
fit <- tryCatch(
lmer(model_formula, data = dat),
error = function(e) return(list(error = e$message, name = name))
)
if (inherits(fit, "list")) {
return(fit)  # error info
}
list(
name = name,
is_singular = isSingular(fit),
convergence_warnings = fit@optinfo$conv$lme4$messages,
summary = summary(fit)
)
})
}
model1 <- y ~ e2_value + p4_value + (1 + e2_value + p4_value | id)
diag_model1 <- run_model_diagnostics(model1, all_sim_data)
model_maximal <- y ~ e2_value + p4_value + (1 + e2_value + p4_value | id)
model_maximal <- y ~ e2_value + p4_value + (1 + e2_value + p4_value | id)
# Run diagnostics for model_maximal
diag_model1 <- run_model_diagnostics(model_maximal, all_sim_data)
# Turning the model diagnostics into a dataframe
diagnostic_overview <- do.call(rbind, lapply(model_diagnostics, function(x) {
if (!is.list(x) || !"name" %in% names(x)) return(NULL)
data.frame(
sim_name = x$name,
is_singular = ifelse("is_singular" %in% names(x), x$is_singular, NA),
has_convergence_warning = ifelse("convergence_warnings" %in% names(x) && !is.null(x$convergence_warnings), TRUE, FALSE),
error = ifelse("error" %in% names(x), x$error, NA),
stringsAsFactors = FALSE
)
}))
# Checking how many models managed to converge
diagnostic_overview %>%
summarise(
num_singular = sum(is_singular, na.rm = TRUE),
num_with_convergence_warning = sum(has_convergence_warning, na.rm = TRUE),
num_with_error = sum(!is.na(error))
)
# Turning the model diagnostics into a dataframe
diagnostic_overview <- do.call(rbind, lapply(diag_model1, function(x) {
if (!is.list(x) || !"name" %in% names(x)) return(NULL)
data.frame(
sim_name = x$name,
is_singular = ifelse("is_singular" %in% names(x), x$is_singular, NA),
has_convergence_warning = ifelse("convergence_warnings" %in% names(x) && !is.null(x$convergence_warnings), TRUE, FALSE),
error = ifelse("error" %in% names(x), x$error, NA),
stringsAsFactors = FALSE
)
}))
# Checking how many models managed to converge
diagnostic_overview %>%
summarise(
num_singular = sum(is_singular, na.rm = TRUE),
num_with_convergence_warning = sum(has_convergence_warning, na.rm = TRUE),
num_with_error = sum(!is.na(error))
)
# Run diagnostics for model_maximal
diag_model_maximal <- run_model_diagnostics(model_maximal, all_sim_data)
# Turning the model diagnostics into a dataframe
diagnostic_overview_maximal <- do.call(rbind, lapply(diag_model_maximal, function(x) {
if (!is.list(x) || !"name" %in% names(x)) return(NULL)
data.frame(
sim_name = x$name,
is_singular = ifelse("is_singular" %in% names(x), x$is_singular, NA),
has_convergence_warning = ifelse("convergence_warnings" %in% names(x) && !is.null(x$convergence_warnings), TRUE, FALSE),
error = ifelse("error" %in% names(x), x$error, NA),
stringsAsFactors = FALSE
)
}))
# Checking how many models managed to converge
diagnostic_overview %>%
summarise(
num_singular = sum(is_singular, na.rm = TRUE),
num_with_convergence_warning = sum(has_convergence_warning, na.rm = TRUE),
num_with_error = sum(!is.na(error))
)
# Checking how many models managed to converge
diagnostic_overview_maximal %>%
summarise(
num_singular = sum(is_singular, na.rm = TRUE),
num_with_convergence_warning = sum(has_convergence_warning, na.rm = TRUE),
num_with_error = sum(!is.na(error))
)
