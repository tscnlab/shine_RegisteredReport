mutate(mel_supp_standardised = (mel_supp - mean(mel_supp))/sd(mel_supp)
)
# Calculating summary statistics on standardised data
mlt_data_standardised_summary <- mlt_data_standardised %>%
summarise(mean = mean(mel_supp_standardised),
sd = sd(mel_supp_standardised),
median = median(mel_supp_standardised),
q1 = quantile(mel_supp_standardised, 0.25),
q3 = quantile(mel_supp_standardised, 0.75)
)
# We start by defining variables of our model
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-5, 5, by = 0.5)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-5, 5, by = 0.5)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-5, 5, by = 0.5)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.1)
noise <- rnorm(1, mean = 0, sd = 0.1)
# Intercept ~ N(intercept_mean, sd = 10% of intercept_mean)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.1 * intercept_mean)
# Slopes ~ N(slope_mean, sd = 10% of slope_mean)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.1 * e2_slope_mean)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.1 * p4_slope_mean)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
#
simulated_data_results_summary <- simulated_data_results %>%
filter(accepted == "yes") %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
# Save results as a csv that we can look at
#write.csv(fake_data_results, "fake_data_results.csv", row.names = FALSE)
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.1)
noise <- rnorm(1, mean = 0, sd = 0.1)
# Intercept ~ N(intercept_mean, sd = 0.1)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.1)
# Slopes ~ N(slope_mean, sd = 0.1)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.1)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.1)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
#
simulated_data_results_summary <- simulated_data_results %>%
filter(accepted == "yes") %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
# Save results as a csv that we can look at
#write.csv(fake_data_results, "fake_data_results.csv", row.names = FALSE)
#
simulated_data_results_summary <- simulated_data_results %>%
filter(accepted == "yes") %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
View(simulated_data_results_summary)
View(simulated_data_results)
# Filter dataset to only accept values within mlt_data q1 and q3
accepted_params <- simulated_data_results %>%
filter(accepted == "yes")
View(accepted_params)
GGally::ggpairs(simulated_data_results[simulated_data_results$accepted == "yes",
c("intercept_mean", "e2_slope_mean", "p4_slope_mean")])
# We start by defining variables of our model
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.5)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-10, 10, by = 0.5)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-10, 10, by = 0.5)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.1)
noise <- rnorm(1, mean = 0, sd = 0.1)
# Intercept ~ N(intercept_mean, sd = 0.1)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.1)
# Slopes ~ N(slope_mean, sd = 0.1)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.1)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.1)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
#
simulated_data_results_summary <- simulated_data_results %>%
filter(accepted == "yes") %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
# Save results as a csv that we can look at
#write.csv(fake_data_results, "fake_data_results.csv", row.names = FALSE)
GGally::ggpairs(simulated_data_results[simulated_data_results$accepted == "yes",
c("intercept_mean", "e2_slope_mean", "p4_slope_mean")])
View(accepted_params)
ggplot2::ggplot() +
geom_histogram(accepted_params, aes(x=e2_slope_mean))
# Filter dataset to only accept values within mlt_data q1 and q3
accepted_params <- simulated_data_results %>%
filter(accepted == "yes")
library(ggplot2)
ggplot(accepted_params, aes(x = intercept_mean)) +
geom_histogram(binwidth = 5, fill = "skyblue", color = "black") +
theme_minimal()
ggplot(accepted_params, aes(x = e2_slope_mean)) +
geom_histogram(binwidth = 0.1, fill = "salmon", color = "black") +
theme_minimal()
ggplot(accepted_params, aes(x = p4_slope_mean)) +
geom_histogram(binwidth = 0.1, fill = "lightgreen", color = "black") +
theme_minimal()
# Get 10th and 90th percentiles to define "central" range
intercept_range <- quantile(accepted_params$intercept_mean, probs = c(0.1, 0.9))
e2_slope_range <- quantile(accepted_params$e2_slope_mean, probs = c(0.1, 0.9))
p4_slope_range <- quantile(accepted_params$p4_slope_mean, probs = c(0.1, 0.9))
# We start by defining variables of our model
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.5)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-100, 100, by = 5)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-100, 100, by = 5)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.1)
noise <- rnorm(1, mean = 0, sd = 0.1)
# Intercept ~ N(intercept_mean, sd = 0.1)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.1)
# Slopes ~ N(slope_mean, sd = 0.1)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.1)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.1)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
#
simulated_data_results_summary <- simulated_data_results %>%
filter(accepted == "yes") %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
# Save results as a csv that we can look at
#write.csv(fake_data_results, "fake_data_results.csv", row.names = FALSE)
# Filter dataset to only accept values within mlt_data q1 and q3
accepted_params <- simulated_data_results %>%
filter(accepted == "yes")
library(ggplot2)
ggplot(accepted_params, aes(x = intercept_mean)) +
geom_histogram(binwidth = 5, fill = "skyblue", color = "black") +
theme_minimal()
ggplot(accepted_params, aes(x = e2_slope_mean)) +
geom_histogram(binwidth = 0.1, fill = "salmon", color = "black") +
theme_minimal()
ggplot(accepted_params, aes(x = p4_slope_mean)) +
geom_histogram(binwidth = 0.1, fill = "lightgreen", color = "black") +
theme_minimal()
# Get 10th and 90th percentiles to define "central" range
intercept_range <- quantile(accepted_params$intercept_mean, probs = c(0.1, 0.9))
e2_slope_range <- quantile(accepted_params$e2_slope_mean, probs = c(0.1, 0.9))
p4_slope_range <- quantile(accepted_params$p4_slope_mean, probs = c(0.1, 0.9))
View(mlt_data_standardised_summary)
View(accepted_params)
GGally::ggpairs(simulated_data_results[simulated_data_results$accepted == "yes",
c("intercept_mean", "e2_slope_mean", "p4_slope_mean")])
# We start by defining variables of our model
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.5)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-10, 10, by = 5)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-10, 10, by = 5)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
# We start by defining variables of our model
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.5)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-10, 10, by = 1)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-10, 10, by = 1)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.1)
noise <- rnorm(1, mean = 0, sd = 0.1)
# Intercept ~ N(intercept_mean, sd = 0.1)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.1)
# Slopes ~ N(slope_mean, sd = 0.1)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.1)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.1)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
# Filter dataset to only accept values within mlt_data q1 and q3
accepted_params <- simulated_data_results %>%
filter(accepted == "yes")
# Summary of accepted paramters
accepted_params_summary <- accepted_params %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
View(accepted_params)
GGally::ggpairs(simulated_data_results[simulated_data_results$accepted == "yes",
c("intercept_mean", "e2_slope_mean", "p4_slope_mean")])
View(accepted_params)
# We start by defining variables of our model
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.5)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-5, 5, by = 2)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-5, 5, by = 2)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.1)
noise <- rnorm(1, mean = 0, sd = 0.1)
# Intercept ~ N(intercept_mean, sd = 0.1)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.1)
# Slopes ~ N(slope_mean, sd = 0.1)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.1)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.1)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
# Filter dataset to only accept values within mlt_data q1 and q3
accepted_params <- simulated_data_results %>%
filter(accepted == "yes")
# Summary of accepted paramters
accepted_params_summary <- accepted_params %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
View(accepted_params)
View(accepted_params)
write.csv(accepted_params, "informed_parameters.csv")
write.csv(accepted_params, "informed_parameters.csv", row.names = FALSE)
