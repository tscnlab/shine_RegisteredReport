p4_slope_sd <- 0.1
# Specify values of E2 and P4 (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Define number of simulations to run
num_simulations <- 1000
# Define threshold for Bayes Factor
bf_threshold <- 3
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric(),
FPR = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (intercept_mean in intercept_mean_list) {
for (e2_slope_mean in e2_slope_mean_list) {
for (p4_slope_mean in p4_slope_mean_list) {
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution (all values have equal probability)
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(1, mean = intercept_mean, sd = intercept_sd)
e2_slope <- rnorm(1, mean = e2_slope_mean, e2_slope_sd)
p4_slope <- rnorm(1, mean = p4_slope_mean, p4_slope_sd)
# Sample noise from normal distribution of mean 0 and sd 0.1
noise <- rnorm(1, mean = 0, sd = 0.1)
# Create all combinations of id and e2 and p4 values
sim_data <- base::expand.grid(id=1:n_ids,
e2_value = e2_value,
p4_value = p4_value)
# Specify model parameters
e2_levels <- e2_slope*e2_value
p4_levels <- p4_slope*p4_value
# Create values for y by solving the equation
sim_data$y <- intercept + e2_levels + p4_levels + noise
# Compute Bayes Factor for full model
bf_full <- BayesFactor::lmBF(y ~ e2_levels + p4_levels,
data = sim_data,
whichRandom = "id")
bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf)$bf)  # Extract BF value
}
# Compute True Positive Rate (TPR)
TPR <- as.numeric(sum(bf_list > bf_threshold) / length(bf_list))
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
}
}
}
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric(),
FPR = numeric()
)
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric(),
FPR = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (intercept_mean in intercept_mean_list) {
for (e2_slope_mean in e2_slope_mean_list) {
for (p4_slope_mean in p4_slope_mean_list) {
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution (all values have equal probability)
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(1, mean = intercept_mean, sd = intercept_sd)
e2_slope <- rnorm(1, mean = e2_slope_mean, e2_slope_sd)
p4_slope <- rnorm(1, mean = p4_slope_mean, p4_slope_sd)
# Sample noise from normal distribution of mean 0 and sd 0.1
noise <- rnorm(1, mean = 0, sd = 0.1)
# Create all combinations of id and e2 and p4 values
sim_data <- base::expand.grid(id=1:n_ids,
e2_value = e2_value,
p4_value = p4_value)
# Specify model parameters
e2_levels <- e2_slope*e2_value
p4_levels <- p4_slope*p4_value
# Create values for y by solving the equation
sim_data$y <- intercept + e2_levels + p4_levels + noise
# Compute Bayes Factor for full model
bf_full <- BayesFactor::lmBF(y ~ e2_levels + p4_levels,
data = sim_data,
whichRandom = "id")
bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf)$bf)  # Extract BF value
}
# Compute True Positive Rate (TPR)
TPR <- as.numeric(sum(bf_list > bf_threshold) / length(bf_list))
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric(),
FPR = numeric()
)
}
}
}
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric(),
FPR = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (intercept_mean in intercept_mean_list) {
for (e2_slope_mean in e2_slope_mean_list) {
for (p4_slope_mean in p4_slope_mean_list) {
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution (all values have equal probability)
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(1, mean = intercept_mean, sd = intercept_sd)
e2_slope <- rnorm(1, mean = e2_slope_mean, e2_slope_sd)
p4_slope <- rnorm(1, mean = p4_slope_mean, p4_slope_sd)
# Sample noise from normal distribution of mean 0 and sd 0.1
noise <- rnorm(1, mean = 0, sd = 0.1)
# Create all combinations of id and e2 and p4 values
sim_data <- base::expand.grid(id=1:n_ids,
e2_value = e2_value,
p4_value = p4_value)
# Specify model parameters
e2_levels <- e2_slope*e2_value
p4_levels <- p4_slope*p4_value
# Create values for y by solving the equation
sim_data$y <- intercept + e2_levels + p4_levels + noise
# Compute Bayes Factor for full model
bf_full <- BayesFactor::lmBF(y ~ e2_levels + p4_levels,
data = sim_data,
whichRandom = "id")
bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf)$bf)  # Extract BF value
}
# Compute True Positive Rate (TPR)
TPR <- as.numeric(sum(bf_list > bf_threshold) / length(bf_list))
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric(),
FPR = numeric()
))
}
}
}
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (intercept_mean in intercept_mean_list) {
for (e2_slope_mean in e2_slope_mean_list) {
for (p4_slope_mean in p4_slope_mean_list) {
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution (all values have equal probability)
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(1, mean = intercept_mean, sd = intercept_sd)
e2_slope <- rnorm(1, mean = e2_slope_mean, e2_slope_sd)
p4_slope <- rnorm(1, mean = p4_slope_mean, p4_slope_sd)
# Sample noise from normal distribution of mean 0 and sd 0.1
noise <- rnorm(1, mean = 0, sd = 0.1)
# Create all combinations of id and e2 and p4 values
sim_data <- base::expand.grid(id=1:n_ids,
e2_value = e2_value,
p4_value = p4_value)
# Specify model parameters
e2_levels <- e2_slope*e2_value
p4_levels <- p4_slope*p4_value
# Create values for y by solving the equation
sim_data$y <- intercept + e2_levels + p4_levels + noise
# Compute Bayes Factor for full model
bf_full <- BayesFactor::lmBF(y ~ e2_levels + p4_levels,
data = sim_data,
whichRandom = "id")
bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf)$bf)  # Extract BF value
}
# Compute True Positive Rate (TPR)
TPR <- as.numeric(sum(bf_list > bf_threshold) / length(bf_list))
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
e2_slope_mean = e2_slope,
p4_slope_mean = p4_slope,
TPR = TPR)
)
}
}
}
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (intercept_mean in intercept_mean_list) {
for (e2_slope_mean in e2_slope_mean_list) {
for (p4_slope_mean in p4_slope_mean_list) {
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution (all values have equal probability)
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(1, mean = intercept_mean, sd = intercept_sd)
e2_slope <- rnorm(1, mean = e2_slope_mean, e2_slope_sd)
p4_slope <- rnorm(1, mean = p4_slope_mean, p4_slope_sd)
# Sample noise from normal distribution of mean 0 and sd 0.1
noise <- rnorm(1, mean = 0, sd = 0.1)
# Create all combinations of id and e2 and p4 values
sim_data <- base::expand.grid(id=1:n_ids,
e2_value = e2_value,
p4_value = p4_value)
# Specify model parameters
e2_levels <- e2_slope*e2_value
p4_levels <- p4_slope*p4_value
# Create values for y by solving the equation
sim_data$y <- intercept + e2_levels + p4_levels + noise
# Compute Bayes Factor for full model
bf_full <- BayesFactor::lmBF(y ~ e2_levels + p4_levels,
data = sim_data,
whichRandom = "id")
bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf)$bf)  # Extract BF value
}
# Compute True Positive Rate (TPR)
TPR <- as.numeric(sum(bf_list > bf_threshold) / length(bf_list))
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
TPR = TPR)
)
}
}
}
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (intercept_mean in intercept_mean_list) {
for (e2_slope_mean in e2_slope_mean_list) {
for (p4_slope_mean in p4_slope_mean_list) {
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution (all values have equal probability)
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(1, mean = intercept_mean, sd = intercept_sd)
e2_slope <- rnorm(1, mean = e2_slope_mean, e2_slope_sd)
p4_slope <- rnorm(1, mean = p4_slope_mean, p4_slope_sd)
# Sample noise from normal distribution of mean 0 and sd 0.1
noise <- rnorm(1, mean = 0, sd = 0.1)
# Create all combinations of id and e2 and p4 values
sim_data <- base::expand.grid(id=1:n_ids,
e2_value = e2_value,
p4_value = p4_value)
# Specify model parameters
sim_data$e2_levels <- e2_slope * sim_data$e2_value
sim_data$p4_levels <- p4_slope * sim_data$p4_value
# Create values for y by solving the equation
sim_data$y <- intercept + sim_data$e2_levels + sim_data$p4_levels + noise
# Compute Bayes Factor for full model
bf_full <- BayesFactor::lmBF(y ~ e2_levels + p4_levels,
data = sim_data,
whichRandom = "id")
bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf_full)$bf) # Extract BF value
}
# Compute True Positive Rate (TPR)
TPR <- as.numeric(sum(bf_list > bf_threshold) / length(bf_list))
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
TPR = TPR)
)
}
}
}
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (intercept_mean in intercept_mean_list) {
for (e2_slope_mean in e2_slope_mean_list) {
for (p4_slope_mean in p4_slope_mean_list) {
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution (all values have equal probability)
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(1, mean = intercept_mean, sd = intercept_sd)
e2_slope <- rnorm(1, mean = e2_slope_mean, e2_slope_sd)
p4_slope <- rnorm(1, mean = p4_slope_mean, p4_slope_sd)
# Simulate data for n_ids individuals
sim_data <- data.frame(
id = factor(1:n_ids),
e2_value = runif(n_ids, e2_min_value, e2_max_value),
p4_value = runif(n_ids, p4_min_value, p4_max_value)
)
# Specify model predictors
sim_data$e2_levels <- e2_slope * sim_data$e2_value
sim_data$p4_levels <- p4_slope * sim_data$p4_value
# Create values for y by solving the equation and add noise
sim_data$y <- intercept + sim_data$e2_levels + sim_data$p4_levels + rnorm(n_ids, mean = 0, sd = 0.1)
# Compute Bayes Factor for full model
bf_full <- BayesFactor::lmBF(y ~ e2_levels + p4_levels,
data = sim_data,
whichRandom = "id")
bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf_full)$bf) # Extract BF value
}
# Compute True Positive Rate (TPR)
TPR <- as.numeric(sum(bf_list > bf_threshold) / length(bf_list))
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
TPR = TPR)
)
}
}
}
View(bfda_simulated_data)
library(tidyverse)
library(BayesFactor)
# Fixed participant number, dictated by resource limitations
n_ids <- 12
# Select possible values for intercept mean, based on what we know worked
intercept_mean_list <- list(informed_parameters$intercept_mean)
# Select possible values for the slopes (i.e. the betas of the predictors), based on what we know worked
e2_slope_mean_list <- list(informed_parameters$e2_slope_mean)
p4_slope_mean_list <- list(informed_parameters$p4_slope_mean)
# Fix the standard deviations for the intercept and slopes, based on what we know worked
intercept_sd <- 0.1
e2_slope_sd <- 0.1
p4_slope_sd <- 0.1
# Specify values of E2 and P4 (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Define number of simulations to run
num_simulations <- 1000
# Define threshold for Bayes Factor
bf_threshold <- 3
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (intercept_mean in intercept_mean_list) {
for (e2_slope_mean in e2_slope_mean_list) {
for (p4_slope_mean in p4_slope_mean_list) {
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution (all values have equal probability)
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(1, mean = intercept_mean, sd = intercept_sd)
e2_slope <- rnorm(1, mean = e2_slope_mean, e2_slope_sd)
p4_slope <- rnorm(1, mean = p4_slope_mean, p4_slope_sd)
# Simulate data for n_ids individuals
sim_data <- data.frame(
id = factor(1:n_ids),
e2_value = runif(n_ids, e2_min_value, e2_max_value),
p4_value = runif(n_ids, p4_min_value, p4_max_value)
)
# Specify model predictors
sim_data$e2_levels <- e2_slope * sim_data$e2_value
sim_data$p4_levels <- p4_slope * sim_data$p4_value
# Create values for y by solving the equation and add noise
sim_data$y <- intercept + sim_data$e2_levels + sim_data$p4_levels + rnorm(n_ids, mean = 0, sd = 0.1)
# Compute Bayes Factor for full model
bf_full <- BayesFactor::lmBF(y ~ e2_levels + p4_levels,
data = sim_data,
whichRandom = "id")
bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf_full)$bf) # Extract BF value
}
# Compute True Positive Rate (TPR)
TPR <- as.numeric(sum(bf_list > bf_threshold) / length(bf_list))
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
TPR = TPR)
)
}
}
}
View(bfda_simulated_data)
# Plot heatmap
ggplot(bfda_simulated_data,aes(x=mean_a,y=mean_b))+
geom_tile(aes(fill=TPR), colour = "black")+
geom_text(aes(label=TPR), colour = "white") +
labs(title = "True positive rate for different means of a and b parameters",
x = "Mean a",
y = "Mean b") +
coord_fixed(ratio=1) +
theme(aspect.ratio = 1)
# Plot heatmap
ggplot(bfda_simulated_data,aes(x=e2_slope_mean,y=p4_slope_mean))+
geom_tile(aes(fill=TPR), colour = "black")+
geom_text(aes(label=TPR), colour = "white") +
labs(title = "True positive rate for different means of a and b parameters",
x = "Mean a",
y = "Mean b") +
coord_fixed(ratio=1) +
theme(aspect.ratio = 1)
# Plot heatmap
ggplot(bfda_simulated_data,aes(x=e2_slope_mean,y=p4_slope_mean))+
geom_tile(aes(fill=TPR), colour = "black")+
geom_text(aes(label=TPR), colour = "white") +
labs(title = "True positive rate for different means of a and b parameters",
x = "E2 slpe mean",
y = "P4 slope mean") +
coord_fixed(ratio=1) +
theme(aspect.ratio = 1)
# Create empty data frame to store simulated data
bfda_simulated_data <- data.frame(e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
TPR = numeric()
)
# Create a for loop to iterate through the possible combinations of parameters (intercept, e2 slopes, and p4 slope)
for (intercept_mean in intercept_mean_list) {
for (e2_slope_mean in e2_slope_mean_list) {
for (p4_slope_mean in p4_slope_mean_list) {
# Store BFs for simulations
bf_list <- numeric(num_simulations)
# Run simulations: for each combination, repeat the simulation 1000 times
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution (all values have equal probability)
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Sample intercept and slopes from normal distribution of defined parameters
intercept <- rnorm(1, mean = intercept_mean, sd = intercept_sd)
e2_slope <- rnorm(1, mean = e2_slope_mean, e2_slope_sd)
p4_slope <- rnorm(1, mean = p4_slope_mean, p4_slope_sd)
# Simulate data for n_ids individuals
sim_data <- data.frame(
id = factor(1:n_ids),
e2_value = runif(n_ids, e2_min_value, e2_max_value),
p4_value = runif(n_ids, p4_min_value, p4_max_value)
)
# Specify model predictors
sim_data$e2_levels <- e2_slope * sim_data$e2_value
sim_data$p4_levels <- p4_slope * sim_data$p4_value
# Create values for y by solving the equation and add noise
sim_data$y <- intercept + sim_data$e2_levels + sim_data$p4_levels + rnorm(n_ids, mean = 0, sd = 0.1)
# Compute Bayes Factor for full model
bf_full <- BayesFactor::lmBF(y ~ e2_levels + p4_levels + id,
data = sim_data,
whichRandom = "id")
bf_list[simulation] <- as.numeric(BayesFactor::extractBF(bf_full)$bf) # Extract BF value
}
# Compute True Positive Rate (TPR)
TPR <- as.numeric(sum(bf_list > bf_threshold) / length(bf_list))
# Store in results
bfda_simulated_data <- rbind(bfda_simulated_data,
data.frame(
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
TPR = TPR)
)
}
}
}
View(bfda_simulated_data)
