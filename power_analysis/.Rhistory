geom_tile(aes(fill = TPR), colour = "black") +
scale_fill_gradient(low = "white", high = "darkgreen", na.value = "grey80", name = "TPR") +
labs(
title = "TPR for P4 slope and intercept means combinations",
subtitle = "100 simulations for each parameter combination\n Grey = missing data",
x = "P4 slope mean",
y = "Intercept mean"
) +
scale_x_continuous(
breaks = seq(-0.5, 0.5, by = 0.1),
limits = c(-0.55, 0.55)
) +
scale_y_continuous(
breaks = seq(-1, 1, by = 0.3),
limits = c(-0.6, 1)
) +
coord_fixed(ratio = 1) +
theme_bw() +
theme(
aspect.ratio = 1,
panel.grid = element_blank(),  # clean up grid lines inside tiles
axis.text = element_text(size = 10),
axis.title = element_text(size = 12)
)
cowplot::plot_grid(e2p4_slopes, e2slope_int, p4slope_int,
labels = c("A", "B", "C"),
ncol = 3,
nrow = 1,
align = "hv")
p4slope_int <- ggplot(simulations_100_complete, aes(x = p4_slope_mean, y = intercept_mean)) +
geom_tile(aes(fill = TPR), colour = "black") +
scale_fill_gradient(low = "white", high = "darkgreen", na.value = "grey80", name = "TPR") +
labs(
title = "TPR for P4 slope and intercept means combinations",
subtitle = "100 simulations for each parameter combination\n Grey = missing data",
x = "P4 slope mean",
y = "Intercept mean"
) +
scale_x_continuous(
breaks = seq(-0.5, 0.5, by = 0.1),
limits = c(-0.55, 0.55)
) +
scale_y_continuous(
breaks = seq(-1, 1, by = 0.3),
limits = c(-0.6, 1)
) +
coord_fixed(ratio = 1) +
theme_bw() +
theme(
aspect.ratio = 1,
panel.grid = element_blank(),  # clean up grid lines inside tiles
axis.text = element_text(size = 10),
axis.title = element_text(size = 12)
)
library(cowplot)
heatmaps_multiplot <- cowplot::plot_grid(e2p4_slopes, e2slope_int, p4slope_int,
labels = c("A", "B", "C"),
ncol = 3,
nrow = 1,
align = "hv")
cowplot::plot_grid(e2p4_slopes, e2slope_int, p4slope_int,
labels = c("A", "B", "C"),
ncol = 3,
nrow = 1,
align = "hv")
ggsave(filename = "heatmaps_multiplot.png",
plot = heatmaps_multiplot,
width = 14,
height = 6,
dpi = 600,
bg = "white")
library(tidyverse)
library(tidyverse)
# Importing data
mlt_data <- read.csv("VR_paper_melatonin_results.csv")
# Calculating summary statistics on raw data
mlt_raw_data_summary <- mlt_data %>%
summarise(mean = mean(mel_supp),
sd = sd(mel_supp),
median = median(mel_supp),
iqr = IQR(mel_supp),
q1 = quantile(mel_supp, 0.25),
q3 = quantile(mel_supp, 0.75))
# Standardise raw data so that it falls between -1 and 1
mlt_data_standardised <- mlt_data %>%
mutate(mel_supp_standardised = (mel_supp - mean(mel_supp))/sd(mel_supp)
)
## QUESTION! The data above is kind of standardised from -1 to 1 but not precisely, i.e. some values are slightly above -1 and 1. Should this formula (mix max scaling) be used instead?
# mutate(mel_supp_minmax = 2 * ((mel_supp - min(mel_supp)) / (max(mel_supp) - min(mel_supp)) - 0.5))
# Calculating summary statistics on standardised data
mlt_data_standardised_summary <- mlt_data_standardised %>%
summarise(mean = mean(mel_supp_standardised),
sd = sd(mel_supp_standardised),
median = median(mel_supp_standardised),
q1 = quantile(mel_supp_standardised, 0.25),
q3 = quantile(mel_supp_standardised, 0.75)
)
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.3)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
set.seed(20250602)
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.3)
noise <- rnorm(1, mean = 0, sd = 0.3)
# Intercept ~ N(intercept_mean, sd = 0.2)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.2)
# Slopes ~ N(slope_mean, sd = 0.2)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.2)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.2)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
# Filter dataset to only accept values within mlt_data q1 and q3
accepted_params <- simulated_data_results %>%
filter(accepted == "yes")
# Summary of accepted paramters
accepted_params_summary <- accepted_params %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
# This should lead to 468 accepted observations.
library(tidyverse)
# Importing data
mlt_data <- read.csv("VR_paper_melatonin_results.csv")
# Calculating summary statistics on raw data
mlt_raw_data_summary <- mlt_data %>%
summarise(mean = mean(mel_supp),
sd = sd(mel_supp),
median = median(mel_supp),
iqr = IQR(mel_supp),
q1 = quantile(mel_supp, 0.25),
q3 = quantile(mel_supp, 0.75))
# Standardise raw data so that it falls between -1 and 1
mlt_data_standardised <- mlt_data %>%
mutate(mel_supp_standardised = (mel_supp - mean(mel_supp))/sd(mel_supp)
)
## QUESTION! The data above is kind of standardised from -1 to 1 but not precisely, i.e. some values are slightly above -1 and 1. Should this formula (mix max scaling) be used instead?
# mutate(mel_supp_minmax = 2 * ((mel_supp - min(mel_supp)) / (max(mel_supp) - min(mel_supp)) - 0.5))
# Calculating summary statistics on standardised data
mlt_data_standardised_summary <- mlt_data_standardised %>%
summarise(mean = mean(mel_supp_standardised),
sd = sd(mel_supp_standardised),
median = median(mel_supp_standardised),
q1 = quantile(mel_supp_standardised, 0.25),
q3 = quantile(mel_supp_standardised, 0.75)
)
library(tidyverse)
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.3)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
set.seed(20250602)
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.3)
noise <- rnorm(1, mean = 0, sd = 0.3)
# Intercept ~ N(intercept_mean, sd = 0.2)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.2)
# Slopes ~ N(slope_mean, sd = 0.2)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.2)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.2)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
# Filter dataset to only accept values within mlt_data q1 and q3
accepted_params <- simulated_data_results %>%
filter(accepted == "yes")
# Summary of accepted paramters
accepted_params_summary <- accepted_params %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
# This should lead to 468 accepted observations.
library(tidyverse)
# Importing data
mlt_data <- read.csv("VR_paper_melatonin_results.csv")
# Calculating summary statistics on raw data
mlt_raw_data_summary <- mlt_data %>%
summarise(mean = mean(mel_supp),
sd = sd(mel_supp),
median = median(mel_supp),
iqr = IQR(mel_supp),
q1 = quantile(mel_supp, 0.25),
q3 = quantile(mel_supp, 0.75))
# Standardise raw data so that it falls between -1 and 1
mlt_data_standardised <- mlt_data %>%
mutate(mel_supp_standardised = (mel_supp - mean(mel_supp))/sd(mel_supp)
)
## QUESTION! The data above is kind of standardised from -1 to 1 but not precisely, i.e. some values are slightly above -1 and 1. Should this formula (mix max scaling) be used instead?
# mutate(mel_supp_minmax = 2 * ((mel_supp - min(mel_supp)) / (max(mel_supp) - min(mel_supp)) - 0.5))
# Calculating summary statistics on standardised data
mlt_data_standardised_summary <- mlt_data_standardised %>%
summarise(mean = mean(mel_supp_standardised),
sd = sd(mel_supp_standardised),
median = median(mel_supp_standardised),
q1 = quantile(mel_supp_standardised, 0.25),
q3 = quantile(mel_supp_standardised, 0.75)
)
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.3)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
library(tidyverse)
# Importing data
mlt_data <- read.csv("VR_paper_melatonin_results.csv")
# Calculating summary statistics on raw data
mlt_raw_data_summary <- mlt_data %>%
summarise(mean = mean(mel_supp),
sd = sd(mel_supp),
median = median(mel_supp),
iqr = IQR(mel_supp),
q1 = quantile(mel_supp, 0.25),
q3 = quantile(mel_supp, 0.75))
# Standardise raw data so that it falls between -1 and 1
mlt_data_standardised <- mlt_data %>%
mutate(mel_supp_standardised = (mel_supp - mean(mel_supp))/sd(mel_supp)
)
# Calculating summary statistics on standardised data
mlt_data_standardised_summary <- mlt_data_standardised %>%
summarise(mean = mean(mel_supp_standardised),
sd = sd(mel_supp_standardised),
median = median(mel_supp_standardised),
q1 = quantile(mel_supp_standardised, 0.25),
q3 = quantile(mel_supp_standardised, 0.75)
)
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.3)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
set.seed(20250602)
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.3)
noise <- rnorm(1, mean = 0, sd = 0.3)
# Intercept ~ N(intercept_mean, sd = 0.2)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.2)
# Slopes ~ N(slope_mean, sd = 0.2)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.2)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.2)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
# Filter dataset to only accept values within mlt_data q1 and q3
accepted_params <- simulated_data_results %>%
filter(accepted == "yes")
# Summary of accepted paramters
accepted_params_summary <- accepted_params %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
# This should lead to 468 accepted observations.
library(tidyverse)
# Importing data
mlt_data <- read.csv("VR_paper_melatonin_results.csv")
# Calculating summary statistics on raw data
mlt_raw_data_summary <- mlt_data %>%
summarise(mean = mean(mel_supp),
sd = sd(mel_supp),
median = median(mel_supp),
iqr = IQR(mel_supp),
q1 = quantile(mel_supp, 0.25),
q3 = quantile(mel_supp, 0.75))
# Standardise raw data so that it falls between -1 and 1
mlt_data_standardised <- mlt_data %>%
mutate(mel_supp_standardised = (mel_supp - mean(mel_supp))/sd(mel_supp)
)
# Calculating summary statistics on standardised data
mlt_data_standardised_summary <- mlt_data_standardised %>%
summarise(mean = mean(mel_supp_standardised),
sd = sd(mel_supp_standardised),
median = median(mel_supp_standardised),
q1 = quantile(mel_supp_standardised, 0.25),
q3 = quantile(mel_supp_standardised, 0.75)
)
# Intercept in standardised scale (since now melatonin data does not go from 0 to 100)
intercept_mean_list <- seq(-1, 1, by = 0.3)
#E2 slope values in standardised scale
e2_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
#P4 slope values in standardised scale
p4_slope_mean_list <- seq(-0.5, 0.5, by = 0.1)
# E2 and P4 values (expressed as standardised values between -1 and 1)
e2_min_value <- -1
e2_max_value <- 1
p4_min_value <- -1
p4_max_value <- 1
# Number of simulations
num_simulations <- 100
# Extract known mlt values from mlt_data_standardised_summary
mlt_data_standardised_q1 <- mlt_data_standardised_summary$q1
mlt_data_standardised_q3 <- mlt_data_standardised_summary$q3
set.seed(20250602)
# Create empty data frame to store results
simulated_data_results <- data.frame(intercept_mean = numeric(),
e2_slope_mean = numeric(),
p4_slope_mean = numeric(),
mean_y = numeric(),
sd_y = numeric(),
accepted = factor())
for (intercept_mean in intercept_mean_list) { # loop over possible intercept means
for (e2_slope_mean in e2_slope_mean_list) { # loop over possible e2 slope means
for (p4_slope_mean in p4_slope_mean_list) { # loop over possible p4 slope means
# Simulate 100 samples of y for each parameter combination
y <- numeric(num_simulations)
for (simulation in seq_len(num_simulations)) {
# Sample E2 and P4 from uniform distribution
e2_value <- runif(1, e2_min_value, e2_max_value)
p4_value <- runif(1, p4_min_value, p4_max_value)
# Noise ~ N(0, sd = 0.3)
noise <- rnorm(1, mean = 0, sd = 0.3)
# Intercept ~ N(intercept_mean, sd = 0.2)
intercept <- rnorm(1, mean = intercept_mean, sd = 0.2)
# Slopes ~ N(slope_mean, sd = 0.2)
e2_slope <- rnorm(1, mean = e2_slope_mean, sd = 0.2)
p4_slope <- rnorm(1, mean = p4_slope_mean, sd = 0.2)
# Model
y[simulation] <- intercept + e2_slope*e2_value + p4_slope*p4_value + noise
}
# Calculate summary stats of y
mean_y <- mean(y)
sd_y <- sd(y)
# Determine if the mean of y is within q1 and q3 of the known melatonin data
accepted <- ifelse(mean_y >= mlt_data_standardised_q1 & mean_y <= mlt_data_standardised_q3, "yes", "no")
# Store results
simulated_data_results <- rbind(simulated_data_results,
data.frame(intercept_mean = intercept_mean,
e2_slope_mean = e2_slope_mean,
p4_slope_mean = p4_slope_mean,
mean_y = mean_y,
sd_y = sd_y,
accepted = factor(accepted)))
}
}
}
# Filter dataset to only accept values within mlt_data q1 and q3
accepted_params <- simulated_data_results %>%
filter(accepted == "yes")
# Summary of accepted paramters
accepted_params_summary <- accepted_params %>%
summarise(min_intercept = min(intercept_mean),
max_intercept = max(intercept_mean),
min_e2 = min(e2_slope_mean),
median_e2 = median(e2_slope_mean),
max_e2 = max(e2_slope_mean),
min_p4 = min(p4_slope_mean),
median_p4 = median(p4_slope_mean),
max_p4 = max(p4_slope_mean))
# This should lead to 468 accepted observations.
View(simulated_data_results)
View(mlt_raw_data_summary)
View(mlt_data_standardised_summary)
View(mlt_data)
View(mlt_data_standardised)
View(mlt_data_standardised_summary)
View(simulated_data_results)
count(p4_slope_mean_list)
length(e2_slope_mean_list)
length(intercept_mean_list)
